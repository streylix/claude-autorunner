#!/bin/bash

# listmsg - List messages in terminal queue via API and local storage
# Usage: listmsg [terminal_number] [status] [options]
# Examples: 
#   listmsg                    # List all messages from all sources
#   listmsg 1                  # List all messages for Terminal 1
#   listmsg 1 pending          # List pending messages for Terminal 1
#   listmsg --local            # List only local frontend messages
#   listmsg --backend          # List only backend API messages
#   listmsg --count            # Show count summary only

# Configuration
API_BASE_URL="http://127.0.0.1:8001/api"
FRONTEND_DATA_FILE="$HOME/Library/Application Support/auto-injector/auto-injector-data.json"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
GRAY='\033[0;37m'
NC='\033[0m' # No Color

# Global options
SHOW_LOCAL=true
SHOW_BACKEND=true
COUNT_ONLY=false
TERMINAL_FILTER=""
STATUS_FILTER=""

# Function to show usage
show_usage() {
    echo "Usage: $0 [terminal_number] [status] [options]"
    echo ""
    echo "Arguments:"
    echo "  terminal_number  Terminal number (1, 2, 3, etc.) - optional"
    echo "  status          Message status (pending, injected, cancelled) - optional"
    echo ""
    echo "Options:"
    echo "  --local         Show only local frontend messages"
    echo "  --backend       Show only backend API messages"
    echo "  --count         Show count summary only"
    echo "  --help, -h      Show this help message"
    echo ""
    echo "Examples:"
    echo "  $0                    # List all messages from all sources"
    echo "  $0 1                  # List all messages for Terminal 1"
    echo "  $0 1 pending          # List pending messages for Terminal 1"
    echo "  $0 --local            # List only local frontend messages"
    echo "  $0 --backend          # List only backend API messages"
    echo "  $0 --count            # Show count summary only"
    echo ""
    exit 1
}

# Function to format timestamp
format_timestamp() {
    local timestamp=$1
    if [[ "$timestamp" =~ ^[0-9]+$ ]]; then
        # JavaScript timestamp (milliseconds)
        date -r $((timestamp / 1000)) "+%Y-%m-%d %H:%M:%S"
    else
        # ISO timestamp
        date -d "$timestamp" "+%Y-%m-%d %H:%M:%S" 2>/dev/null || echo "$timestamp"
    fi
}

# Function to format time from now
time_from_now() {
    local timestamp=$1
    local current_time=$(date +%s)
    local message_time
    
    if [[ "$timestamp" =~ ^[0-9]+$ ]]; then
        # JavaScript timestamp (milliseconds)
        message_time=$((timestamp / 1000))
    else
        # ISO timestamp
        message_time=$(date -d "$timestamp" +%s 2>/dev/null || echo "$current_time")
    fi
    
    local diff=$((message_time - current_time))
    
    if [ $diff -gt 0 ]; then
        if [ $diff -lt 60 ]; then
            echo "in ${diff}s"
        elif [ $diff -lt 3600 ]; then
            echo "in $((diff / 60))m"
        else
            echo "in $((diff / 3600))h"
        fi
    elif [ $diff -gt -60 ]; then
        echo "just now"
    elif [ $diff -gt -3600 ]; then
        echo "$(((-diff) / 60))m ago"
    else
        echo "$(((-diff) / 3600))h ago"
    fi
}

# Function to get terminal sessions
get_terminal_sessions() {
    local terminal_num=$1
    local terminal_name="Terminal $terminal_num"
    
    local session_data=$(curl -s "$API_BASE_URL/terminal/sessions/" 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}Warning: Could not connect to backend API${NC}" >&2
        return 1
    fi
    
    # Parse JSON to find terminal session IDs with matching name
    local session_ids=$(echo "$session_data" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    session_ids = []
    for session in data:
        if session['name'] == '$terminal_name':
            session_ids.append(session['id'])
    print(' '.join(session_ids))
except:
    pass
" 2>/dev/null)
    
    echo "$session_ids"
    return 0
}

# Function to list backend messages
list_backend_messages() {
    local terminal_filter=$1
    local status_filter=$2
    
    echo -e "${BLUE}=== Backend API Messages ===${NC}"
    
    # Build query parameters
    local query_params=""
    if [ -n "$terminal_filter" ]; then
        local session_ids=$(get_terminal_sessions "$terminal_filter")
        if [ -n "$session_ids" ]; then
            for session_id in $session_ids; do
                if [ -n "$query_params" ]; then
                    query_params="${query_params}&"
                fi
                query_params="${query_params}terminal_session=${session_id}"
            done
        fi
    fi
    
    if [ -n "$status_filter" ]; then
        if [ -n "$query_params" ]; then
            query_params="${query_params}&"
        fi
        query_params="${query_params}status=${status_filter}"
    fi
    
    # Build URL
    local url="$API_BASE_URL/queue/queue/"
    if [ -n "$query_params" ]; then
        url="${url}?${query_params}"
    fi
    
    # Get messages
    local messages=$(curl -s "$url" 2>/dev/null)
    
    if [ $? -ne 0 ]; then
        echo -e "${RED}Error: Could not connect to backend API at $API_BASE_URL${NC}"
        return 1
    fi
    
    # Parse and display messages
    echo "$messages" | python3 -c "
import json, sys
from datetime import datetime, timezone

try:
    data = json.load(sys.stdin)
    if not data:
        print('No messages found in backend queue')
        sys.exit(0)
    
    for msg in data:
        # Status color
        status = msg.get('status', 'unknown')
        if status == 'pending':
            status_color = '\033[1;33m'  # Yellow
        elif status == 'injected':
            status_color = '\033[0;32m'  # Green  
        elif status == 'cancelled':
            status_color = '\033[0;31m'  # Red
        else:
            status_color = '\033[0;37m'  # Gray
            
        # Terminal session info
        terminal_session = msg.get('terminal_session', {})
        terminal_name = terminal_session.get('name', 'Unknown')
        
        # Timestamps
        created_at = msg.get('created_at', '')
        scheduled_for = msg.get('scheduled_for', '')
        injected_at = msg.get('injected_at', '')
        
        # Content (truncated)
        content = msg.get('content', '')
        if len(content) > 80:
            content = content[:77] + '...'
        
        print(f'[{status_color}{status.upper():>9}\033[0m] {terminal_name:>12} | {content}')
        print(f'         Created: {created_at[:19]} | ID: {msg.get(\"id\", \"unknown\")[:8]}')
        if scheduled_for:
            print(f'       Scheduled: {scheduled_for[:19]}')
        if injected_at:
            print(f'        Injected: {injected_at[:19]}')
        print()
        
except Exception as e:
    print(f'Error parsing backend messages: {e}')
    sys.exit(1)
"
}

# Function to list local frontend messages
list_local_messages() {
    local terminal_filter=$1
    local status_filter=$2
    
    echo -e "${CYAN}=== Local Frontend Messages ===${NC}"
    
    if [ ! -f "$FRONTEND_DATA_FILE" ]; then
        echo -e "${YELLOW}No local frontend data file found${NC}"
        return 1
    fi
    
    # Parse local messages
    python3 -c "
import json, sys
from datetime import datetime

try:
    with open('$FRONTEND_DATA_FILE', 'r') as f:
        data = json.load(f)
    
    messages = data.get('messages', [])
    message_history = data.get('messageHistory', [])
    
    # Filter messages
    filtered_messages = []
    
    # Process pending messages
    for msg in messages:
        if '$status_filter' and msg.get('status', 'pending') != '$status_filter':
            continue
        if '$terminal_filter' and msg.get('terminal_id') != int('$terminal_filter' or 0):
            continue
        filtered_messages.append(('PENDING', msg))
    
    # Process history messages (if status allows)
    if not '$status_filter' or '$status_filter' == 'injected':
        for msg in message_history:
            if '$terminal_filter' and msg.get('terminalId') != int('$terminal_filter' or 0):
                continue
            filtered_messages.append(('HISTORY', msg))
    
    if not filtered_messages:
        print('No messages found in local storage')
        sys.exit(0)
    
    # Sort by timestamp
    def get_timestamp(item):
        msg_type, msg = item
        if msg_type == 'PENDING':
            return msg.get('created_at', 0)
        else:
            return msg.get('timestamp', 0)
    
    filtered_messages.sort(key=get_timestamp, reverse=True)
    
    for msg_type, msg in filtered_messages:
        if msg_type == 'PENDING':
            # Pending message
            status = msg.get('status', 'pending')
            status_color = '\033[1;33m' if status == 'pending' else '\033[0;32m'
            
            terminal_id = msg.get('terminal_id', 1)
            content = msg.get('content', '')
            if len(content) > 80:
                content = content[:77] + '...'
            
            execute_at = msg.get('execute_at', 0)
            created_at = msg.get('created_at', 0)
            
            print(f'[{status_color}{status.upper():>9}\033[0m] Terminal {terminal_id:>7} | {content}')
            print(f'         Created: {datetime.fromtimestamp(created_at/1000).strftime(\"%Y-%m-%d %H:%M:%S\")}')
            if execute_at:
                print(f'         Execute: {datetime.fromtimestamp(execute_at/1000).strftime(\"%Y-%m-%d %H:%M:%S\")}')
            print(f'              ID: {msg.get(\"message_id\", \"unknown\")}')
            print()
            
        else:
            # History message
            content = msg.get('content', '')
            if len(content) > 80:
                content = content[:77] + '...'
            
            terminal_id = msg.get('terminalId', 1)
            timestamp = msg.get('timestamp', 0)
            
            print(f'[\033[0;32m INJECTED\033[0m] Terminal {terminal_id:>7} | {content}')
            print(f'         Executed: {datetime.fromtimestamp(timestamp/1000).strftime(\"%Y-%m-%d %H:%M:%S\")}')
            print(f'          Counter: {msg.get(\"counter\", \"unknown\")}')
            print()
            
except Exception as e:
    print(f'Error parsing local messages: {e}')
    sys.exit(1)
"
}

# Function to show count summary
show_count_summary() {
    echo -e "${MAGENTA}=== Message Count Summary ===${NC}"
    
    local backend_total=0
    local backend_pending=0
    local backend_injected=0
    local backend_cancelled=0
    
    local local_total=0
    local local_pending=0
    local local_history=0
    
    # Get backend counts
    if [ "$SHOW_BACKEND" = true ]; then
        local backend_data=$(curl -s "$API_BASE_URL/queue/queue/" 2>/dev/null)
        if [ $? -eq 0 ]; then
            backend_counts=$(echo "$backend_data" | python3 -c "
import json, sys
try:
    data = json.load(sys.stdin)
    total = len(data)
    pending = len([m for m in data if m.get('status') == 'pending'])
    injected = len([m for m in data if m.get('status') == 'injected'])
    cancelled = len([m for m in data if m.get('status') == 'cancelled'])
    print(f'{total} {pending} {injected} {cancelled}')
except:
    print('0 0 0 0')
")
            read backend_total backend_pending backend_injected backend_cancelled <<< "$backend_counts"
        fi
    fi
    
    # Get local counts
    if [ "$SHOW_LOCAL" = true ] && [ -f "$FRONTEND_DATA_FILE" ]; then
        local_counts=$(python3 -c "
import json, sys
try:
    with open('$FRONTEND_DATA_FILE', 'r') as f:
        data = json.load(f)
    
    messages = data.get('messages', [])
    history = data.get('messageHistory', [])
    
    pending = len([m for m in messages if m.get('status', 'pending') == 'pending'])
    total = pending + len(history)
    
    print(f'{total} {pending} {len(history)}')
except:
    print('0 0 0')
")
        read local_total local_pending local_history <<< "$local_counts"
    fi
    
    # Display summary
    if [ "$SHOW_BACKEND" = true ]; then
        echo -e "${BLUE}Backend API:${NC}"
        echo -e "  Total: ${backend_total}"
        echo -e "  Pending: ${YELLOW}${backend_pending}${NC}"
        echo -e "  Injected: ${GREEN}${backend_injected}${NC}"
        echo -e "  Cancelled: ${RED}${backend_cancelled}${NC}"
        echo
    fi
    
    if [ "$SHOW_LOCAL" = true ]; then
        echo -e "${CYAN}Local Frontend:${NC}"
        echo -e "  Total: ${local_total}"
        echo -e "  Pending: ${YELLOW}${local_pending}${NC}"
        echo -e "  History: ${GREEN}${local_history}${NC}"
        echo
    fi
    
    local combined_total=$((backend_total + local_total))
    local combined_pending=$((backend_pending + local_pending))
    
    echo -e "${MAGENTA}Combined:${NC}"
    echo -e "  Total Messages: ${combined_total}"
    echo -e "  Pending: ${YELLOW}${combined_pending}${NC}"
    echo -e "  Processed: ${GREEN}$((backend_injected + local_history))${NC}"
}

# Parse command line arguments
while [[ $# -gt 0 ]]; do
    case $1 in
        --local)
            SHOW_LOCAL=true
            SHOW_BACKEND=false
            shift
            ;;
        --backend)
            SHOW_BACKEND=true
            SHOW_LOCAL=false
            shift
            ;;
        --count)
            COUNT_ONLY=true
            shift
            ;;
        --help|-h)
            show_usage
            ;;
        *)
            if [[ "$1" =~ ^[0-9]+$ ]]; then
                TERMINAL_FILTER="$1"
            elif [[ "$1" =~ ^(pending|injected|cancelled)$ ]]; then
                STATUS_FILTER="$1"
            else
                echo -e "${RED}Error: Unknown argument '$1'${NC}" >&2
                show_usage
            fi
            shift
            ;;
    esac
done

# Main execution
main() {
    if [ "$COUNT_ONLY" = true ]; then
        show_count_summary
        exit 0
    fi
    
    echo -e "${MAGENTA}=== Terminal Queue Messages ===${NC}"
    echo
    
    if [ "$SHOW_BACKEND" = true ]; then
        list_backend_messages "$TERMINAL_FILTER" "$STATUS_FILTER"
        echo
    fi
    
    if [ "$SHOW_LOCAL" = true ]; then
        list_local_messages "$TERMINAL_FILTER" "$STATUS_FILTER"
        echo
    fi
    
    if [ "$SHOW_BACKEND" = true ] && [ "$SHOW_LOCAL" = true ]; then
        show_count_summary
    fi
}

# Run main function
main